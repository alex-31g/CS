**_Структуры данных и алгоритмы - это материалы для построения программ._**

## Big O нотация

**Алгоритм** - последовательность операций для решения определенной задачи.

Для **оценки сложности алгоритмов** существуют две характеристики:
- оценка по времени - какое количество операций необходимо выполнить алгоритму для достижения результата
- оценка по памяти - какое количество дополнительной памяти необходимо алгоритму для достижения результата

Главная характеристика, которую следует учитывать при выборе алгоритма (на языке JS) - это оценка по времени.

Для описания сложности алгоритма используется **Big O нотация**.    
Её цель - показать зависимость количества операций, выполняемых алгоритмом, от количества входящих данных.   
Другими словами, с её помощью мы можем определить - какой алгоритм потребляет меньше ресурсов при росте входящих данных.

Запись сложности алгоритма в 'Big O нотации' выглядит следующим образом - **О()**, например:
- O(1) читается как 'О от единицы' или 'сложность порядка 1' или 'константная сложность'
- O(N) читается как 'О от N' или 'сложность порядка N' или 'линейная сложность'  

**Классификация сложностей алгоритмов**:       
![](./imgs/Сложности-алгоритмов.png)

![](./imgs/Графики-алгоритмов.png)

## O(1) - константная сложность

Имеем ф-цию, которая принимает массив и возвращает первый элемент в квадрате:
```js
function getFirstEl(arr) {
	let el = arr[0];
	let elSquared = el * el;
	return elSquared;
}

console.log(getFirstEl([10,15,20])); // 100
```
Независимо от того, какой длины массив будет передан в ф-цию - потребуется только одна операция для всех возможных входных данных.   
Данный алгоритм выполняется за постоянное/константное время (constant time) и его сложность описывается как **O(1)**.

O(1) алгоритмы самые эффективные.

**ВАЖНО:**   
Фактически операций в коде выше три, а не одна: 
- Получение первого элемента массива (1 операция)
- Возведение элемента в квадрат (1 операция)
- Возврат значения из функции (1 операция)

Почему тогда сложность описывается как O(1), а не O(3)?   
В Big O нотации фактическое кол-во шагов не важно, важно что алгоритм выполняется за константное время.    
Алгоритмы с константным временем это всегда O(1). 

## O(N) - линейная сложность

Имеем ф-цию, которая принимает массив и возвращает сумму элементов массива:
```js
function getSum(arr) {
	let sum = 0;
	for(let el of arr){
		sum += el;
	}
	return sum;
}

console.log(getSum([10,15,20])); // 45
```
Здесь нужно перебрать все элементы, т.е. происходит операция на каждом элементе и чем больше элементов, тем больше операций, следовательно, затраченное время увеличивается линейно.
Сложность данного алгоритма описывается как **O(N)**.

**ВАЖНО:**   
Фактически операций в коде выше три, а не одна: 
- Создание переменной let sum = 0 (1 операция)
- Перебор элементов массива в цикле + Обновление значения sum внутри цикла (N * 1 операцию)
- Возврат значения из функции (1 операция)

Почему тогда сложность описывается как O(N), а не O(2 + N*1)?   


## Правильный выбор алгоритма 

Рассмотрим пример того, почему важно сделать правильный выбор алгоритма.   
Для этого напишем две ф-ции, которые будут решать одинаковую задачу.   
Первая ф-ция имеет O(N)-сложность, вторая O(1).   

*Ф-ция принимает число n и возвращает сумму чисел от 1 до n.*       
*Например, если n = 3, то возвращаемый результат будет равен 6 (1 + 2 + 3)*:
```js
// Метод performance.now() - возвращает временную метку, измеряемую в миллисекундах, с точностью до одной тысячной миллисекунды
const { performance } = require('perf_hooks');

// =================
// Вариант 1 - O(N)
// =================
function sum(n) {
	let res = 0;
	for (let i = 1; i <= n; i++) {
		res += i;
	}
	return res;
}
let start = performance.now();
sum(1000);
let end = performance.now();
console.log(end - start); // 10.397899001836777 

// =================
// Вариант 2 - O(1) 
// =================
function sum2(n) {
	let res = (n / 2) * (1 + n); // Математическая формула
	return res;
}
let start2 = performance.now();
sum2(1000);
let end2 = performance.now();
console.log(end2 - start2); // 1.5142000019550323 
```

Как видно из примера выше, при одинаковых входных параметрах равных 1000, эффективность варианта 2 (*O(1)-сложность*) почти в 10 раз выше, чем варианта 1 (*O(N)-сложность*).   
Если мы изменим входные параметры на 1000.000.000, то результат будет следующим:
- 1581.8106000125408 (вариант 1)
- 1.2152000069618225 (вариант 2)   
 
Как видим, эффективность варианта 2 уже в 1500 раз выше, чем варианта 1. При этом для варианта 2 неважно насколько большое число поступает в ф-цию - его эффективность всегда на одинаковом уровне (**constant**), в то время как эффективность варианта 1 - зависит от величины входного параметра - чем больше число, тем больше итераций цикла, следовательно, затраченное время увеличивается линейно (**linear**):

![](./imgs/01.1.png)

Следовательно, алгоритм O(1) гораздо эффективнее и он выполняется за «постоянное/константное время».